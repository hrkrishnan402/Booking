import 'dart:convert';
import 'dart:io';
import 'package:http/http.dart';
import 'package:http_retry/http_retry.dart';
import 'package:logger/logger.dart';
import 'api_exception.dart';
import 'api_helper.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';

/// This Class Provide a Single Wrapper Method for All HTTP [Client]
/// Methods
/// This is actually a modified version of [ApiClient] Class
/// that is automatically generated by openapitool
/// So be mindful when you make changes to this file
class ApiClient {
  final FlutterSecureStorage secureStorage = const FlutterSecureStorage();
  var _client = RetryClient(
    Client(),
    retries: 5,
  );

  /// Returns the current HTTP [Client] instance to use in this class.
  ///
  /// The return value is guaranteed to never be null.
  RetryClient get client => _client;

  static final ApiClient _singleton = ApiClient._internal();

  factory ApiClient() {
    return _singleton;
  }

  ApiClient._internal();

  /// Requests to use a new HTTP [Client] in this class.
  ///
  /// If the [newClient] is null, an [ArgumentError] is thrown.
  set client(RetryClient newClient) {
    // ignore: unnecessary_null_comparison
    if (newClient == null) {
      throw ArgumentError('New client instance cannot be null.');
    }
    _client = newClient;
  }

  final _defaultHeaderMap = <String, String>{};

  void addDefaultHeader(String key, String value) {
    _defaultHeaderMap[key] = value;
  }

  Map<String, String> get defaultHeaderMap => _defaultHeaderMap;
  // We don’t use a Map<String, String> for queryParams.
  // If collectionFormat is 'multi', a key might appear multiple times.

  // ignore: unnecessary_null_comparison
  String serialize(Object obj) => obj == null ? '' : json.encode(obj);

  Future<Response> invokeAPI(String path, String method,
      {Object body = "",
      Iterable<QueryParam>? queryParams,
      Map<String, String>? headerParams,
      Map<String, String>? formParams,
      String? nullableContentType}) async {
    queryParams = queryParams ?? <QueryParam>[];
    headerParams = headerParams ?? <String, String>{};
    formParams = formParams ?? <String, String>{};
    headerParams.addAll(_defaultHeaderMap);
    final urlEncodedQueryParams = queryParams
        // ignore: unnecessary_null_comparison
        .where((param) => param.value != null)
        .map((param) => '$param');

    final queryString = urlEncodedQueryParams.isNotEmpty
        ? '?${urlEncodedQueryParams.join('&')}'
        : '';

    final url = '$path$queryString';

    if (nullableContentType != null) {
      headerParams['Content-Type'] = nullableContentType;
    }

    final storedToken = await secureStorage.read(key: 'jwt');
    if (storedToken != null && storedToken.isNotEmpty) {
      headerParams['Authorization'] = 'Bearer $storedToken';
      Logger().w(storedToken+">>>>>>>>>>>>>>>>>>>>>>>>>>>>");
    }
    try {
      // Special case for uploading a single file which isn’t a 'multipart/form-data'.
      if (body is MultipartFile &&
          (nullableContentType == null ||
              !nullableContentType
                  .toLowerCase()
                  .startsWith('multipart/form-data'))) {
        final request = StreamedRequest(method, Uri.parse(url));
        request.headers.addAll(headerParams);
        request.contentLength = body.length;
        body.finalize().listen(
              request.sink.add,
              onDone: request.sink.close,
              onError: (error, trace) => request.sink.close(),
              cancelOnError: true,
            );
        final response = await _client.send(request);
        return Response.fromStream(response);
      }

      if (body is MultipartRequest) {
        final request = MultipartRequest(method, Uri.parse(url));
        request.fields.addAll(body.fields);
        request.files.addAll(body.files);
        request.headers.addAll(body.headers);
        request.headers.addAll(headerParams);
        final response = await _client.send(request);
        return Response.fromStream(response);
      }

      final msgBody = nullableContentType == 'application/x-www-form-urlencoded'
          ? formParams
          : serialize(body);
      final nullableHeaderParams = headerParams.isEmpty ? null : headerParams;
      Response response = Response("{status:300}", 300);
      switch (method) {
        case 'POST':
          response = await _client.post(
            Uri.parse(url),
            headers: nullableHeaderParams,
            body: msgBody,
          );
          break;
        case 'PUT':
          response = await _client.put(
            Uri.parse(url),
            headers: nullableHeaderParams,
            body: msgBody,
          );
          break;
        case 'DELETE':
          response = await _client.delete(
            Uri.parse(url),
            headers: nullableHeaderParams,
          );
          break;
        case 'PATCH':
          response = await _client.patch(
            Uri.parse(url),
            headers: nullableHeaderParams,
            body: msgBody,
          );
          break;
        case 'HEAD':
          response = await _client.head(
            Uri.parse(url),
            headers: nullableHeaderParams,
          );
          break;
        case 'GET':
          response = await _client.get(
            Uri.parse(url),
            headers: nullableHeaderParams,
          );
          break;
      }
      return response;
    } on SocketException catch (e, trace) {
      throw ApiException.withInner(
        HttpStatus.requestTimeout,
        'Socket operation failed: $method $path',
        e,
        trace,
      );
    } on TlsException catch (e, trace) {
      throw ApiException.withInner(
        HttpStatus.requestTimeout,
        'TLS/SSL communication failed: $method $path',
        e,
        trace,
      );
    } on IOException catch (e, trace) {
      throw ApiException.withInner(
        HttpStatus.requestTimeout,
        'I/O operation failed: $method $path',
        e,
        trace,
      );
    } on ClientException catch (e, trace) {
      throw ApiException.withInner(
        HttpStatus.clientClosedRequest,
        // 'HTTP connection failed: $method $path',
        "Unable to Reach Server",
        e,
        trace,
      );
    } on Exception catch (e, trace) {
      throw ApiException.withInner(
        HttpStatus.requestTimeout,
        'Exception occurred: $method $path',
        e,
        trace,
      );
    }
  }
}
